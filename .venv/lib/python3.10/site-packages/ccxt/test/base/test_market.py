import os
import sys

root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
sys.path.append(root)

# ----------------------------------------------------------------------------

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

# ----------------------------------------------------------------------------
# -*- coding: utf-8 -*-


from ccxt.test.base import test_shared_methods  # noqa E402


def test_market(exchange, method, market):
    format = {
        'id': 'btcusd',
        'symbol': 'BTC/USD',
        'base': 'BTC',
        'quote': 'USD',
        'taker': exchange.parse_number('0.0011'),
        'maker': exchange.parse_number('0.0009'),
        'baseId': 'btc',
        'quoteId': 'usd',
        'active': True,
        'type': 'spot',
        'linear': False,
        'inverse': False,
        'spot': True,
        'swap': False,
        'future': False,
        'option': False,
        'margin': False,
        'contract': False,
        'contractSize': exchange.parse_number('0.001'),
        'expiry': 1656057600000,
        'expiryDatetime': '2022-06-24T08:00:00.000Z',
        'optionType': 'put',
        'strike': exchange.parse_number('56000'),
        'settle': 'XYZ',
        'settleId': 'Xyz',
        'precision': {
            'price': exchange.parse_number('8'),
            'amount': exchange.parse_number('8'),
            'cost': exchange.parse_number('8'),
        },
        'limits': {
            'amount': {
                'min': exchange.parse_number('0.01'),
                'max': exchange.parse_number('1000'),
            },
            'price': {
                'min': exchange.parse_number('0.01'),
                'max': exchange.parse_number('1000'),
            },
            'cost': {
                'min': exchange.parse_number('0.01'),
                'max': exchange.parse_number('1000'),
            },
        },
        'info': {},
    }
    empty_not_allowed_for = ['id', 'symbol', 'base', 'quote', 'baseId', 'quoteId', 'precision', 'limits', 'type', 'spot', 'swap', 'future', 'contract']
    test_shared_methods.assert_structure(exchange, method, market, format, empty_not_allowed_for)
    test_shared_methods.assert_symbol(exchange, method, market, 'symbol')
    log_text = test_shared_methods.log_template(exchange, method, market)
    #
    test_shared_methods.assert_greater(exchange, method, market, 'contractSize', '0')
    test_shared_methods.assert_greater(exchange, method, market, 'expiry', '0')
    test_shared_methods.assert_greater(exchange, method, market, 'strike', '0')
    test_shared_methods.assert_in_array(exchange, method, market, 'optionType', ['put', 'call'])
    test_shared_methods.assert_greater(exchange, method, market, 'taker', '-100')
    test_shared_methods.assert_greater(exchange, method, market, 'maker', '-100')
    if market['contract']:
        assert market['linear'] != market['inverse'], 'market linear and inverse must not be the same' + log_text
    else:
        assert (market['linear'] is None) and (market['inverse'] is None), 'market linear and inverse must be undefined when \"contract\" is false' + log_text
    if market['option']:
        assert market['strike'] is not None, '\"strike\" must be defined when \"option\" is true' + log_text
        assert market['optionType'] is not None, '\"optionType\" must be defined when \"option\" is true' + log_text
    valid_types = ['spot', 'margin', 'swap', 'future', 'option']
    test_shared_methods.assert_in_array(exchange, method, market, 'type', valid_types)
    types = valid_types
    for i in range(0, len(types)):
        test_shared_methods.assert_in_array(exchange, method, market, types[i], [True, False, None])
    if market['future']:
        assert not market['swap'] and not market['option'], 'market swap and option must be false when \"future\" is true' + log_text
    elif market['swap']:
        assert not market['future'] and not market['option'], 'market future and option must be false when \"swap\" is true' + log_text
    elif market['option']:
        assert not market['future'] and not market['swap'], 'market future and swap must be false when \"option\" is true' + log_text
    if market['linear']:
        assert not market['inverse'], 'market inverse must be false when \"linear\" is true' + log_text
    elif market['inverse']:
        assert not market['linear'], 'market linear must be false when \"inverse\" is true' + log_text
    if market['future']:
        assert market['expiry'] is not None, '\"expiry\" must be defined when \"future\" is true' + log_text
        assert market['expiryDatetime'] is not None, '\"expiryDatetime\" must be defined when \"future\" is true' + log_text
    if market['expiry'] is not None:
        assert market['expiryDatetime'] == exchange.iso8601(market['expiry']), 'expiryDatetime must be equal to expiry in iso8601 format' + log_text
    target_keys = ['cost', 'amount', 'price']
    # check precisions
    for i in range(0, len(target_keys)):
        key = target_keys[i]
        # todo: should be migrated into assertGreater after TickSize handling is implemented
        test_shared_methods.assert_greater_or_equal(exchange, method, market['precision'], key, '0')
    # check limits
    for i in range(0, len(target_keys)):
        key = target_keys[i]
        limit_entry = market['limits'][key]
        test_shared_methods.assert_greater_or_equal(exchange, method, limit_entry, 'min', '0')
        test_shared_methods.assert_greater(exchange, method, limit_entry, 'max', '0')
